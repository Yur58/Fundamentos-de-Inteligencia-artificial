import cv2, time
from collections import Counter
from ultralytics import YOLO

# ---------- Ajustes ----------
MODEL_PATH = r"C:\Users\eliam\Downloads\mejor_modelo.pt"
CLASS_NAMES = ['capacitor', 'capacitor no polarizado', 'led', 'resistencia']
SOURCE = 1          # webcam: 0, o pon ruta de video
CONF_TH = 0.45      # sube para reducir FPs (0.35–0.60)
IOU_TH  = 0.55
IMG_SZ  = 640       # 640 o 896 para objetos pequeños
SHOW_IDS = set(range(len(CLASS_NAMES)))  # o filtra p.ej. {0,1,2,3}

# Mapa de nombre->índice (según su orden en CLASS_NAMES)
IDX = {name: i for i, name in enumerate(CLASS_NAMES)}

# ---------- Cargar modelo ----------
model = YOLO(MODEL_PATH)  # usa GPU si disponible

cap = cv2.VideoCapture(SOURCE)
if not cap.isOpened():
    raise RuntimeError("No pude abrir la cámara/video")

# ---------- Loop ----------
t0, frames = time.time(), 0
while True:
    ok, frame = cap.read()
    if not ok:
        break

    # Predicción (una sola imagen)
    results = model.predict(
        frame, imgsz=IMG_SZ, conf=CONF_TH, iou=IOU_TH, verbose=False
    )

    # Tomamos el primer resultado
    r = results[0]
    boxes = r.boxes

    # Conteos por índice (0-inicializados)
    counts_idx = [0] * len(CLASS_NAMES)

    if boxes is not None and len(boxes) > 0:
        xyxy = boxes.xyxy.cpu().numpy()
        cls  = boxes.cls.cpu().numpy().astype(int)
        conf = boxes.conf.cpu().numpy()

        for (x1, y1, x2, y2), c, p in zip(xyxy, cls, conf):
            if c in SHOW_IDS:
                counts_idx[c] += 1
                # Dibujo de bbox + etiqueta
                x1, y1, x2, y2 = map(int, (x1, y1, x2, y2))
                cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 2)
                label_text = f"{CLASS_NAMES[c]} {p:.2f}"
                cv2.putText(frame, label_text, (x1, max(12, y1 - 6)),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2, cv2.LINE_AA)

    # --------- Overlay ÚNICO con el formato pedido ---------
    # Mapeo explícito: Leds <- 'led'; Res <- 'resistencia'; Cap <- 'capacitor'; CapNoPol <- 'capacitor no polarizado'
    num_leds     = counts_idx[IDX['led']]
    num_res      = counts_idx[IDX['resistencia']]
    num_cap      = counts_idx[IDX['capacitor']]
    num_capnop   = counts_idx[IDX['capacitor no polarizado']]

    overlay_text = f"Leds: {num_leds}, Res: {num_res}, Cap: {num_cap}, CapNoPol: {num_capnop}"

    # Fondo para legibilidad
    font = cv2.FONT_HERSHEY_SIMPLEX
    font_scale = 0.8
    thickness = 2
    (tw, th), baseline = cv2.getTextSize(overlay_text, font, font_scale, thickness)
    pad = 6
    x1_bg, y1_bg = 8, 8
    x2_bg, y2_bg = x1_bg + tw + 2*pad, y1_bg + th + baseline + 2*pad
    cv2.rectangle(frame, (x1_bg, y1_bg), (x2_bg, y2_bg), (0, 0, 0), -1)
    cv2.putText(frame, overlay_text, (x1_bg + pad, y1_bg + th + pad),
                font, font_scale, (255, 255, 255), thickness, cv2.LINE_AA)

    # FPS
    frames += 1
    dt = time.time() - t0
    if dt > 0:
        fps = frames / dt
        cv2.putText(frame, f"FPS: {fps:.1f}", (frame.shape[1]-130, 24),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255,255,0), 2, cv2.LINE_AA)

    cv2.imshow("YOLOv11 - Realtime", frame)
    if cv2.waitKey(1) & 0xFF in (27, ord('q')):  # ESC o q
        break

cap.release()
cv2.destroyAllWindows()
